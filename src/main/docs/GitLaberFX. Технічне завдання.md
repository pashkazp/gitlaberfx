# **GitLaberFX: Технічне завдання (версія 2.0)**

Цей документ описує технічні та функціональні вимоги до десктопного додатку GitLaberFX, відображаючи його поточний стан після архітектурного рефакторингу.

## **1\. Загальна інформація**

### **1.1 Назва проєкту**

GitLab Branch Manager (GitLaberFX)

### **1.2 Мета проєкту**

Розробка надійного та ефективного десктопного додатку для автоматизованого управління гілками в GitLab, що спрощує підтримку порядку в репозиторіях шляхом масового видалення застарілих гілок.

### **1.3 Цільова платформа**

* **Технології:** Java 17, JavaFX, Maven.  
* **ОС:** Windows, Linux, macOS.

## **2\. Функціональні вимоги**

### **2.1 Управління проєктами**

* Динамічне завантаження та відображення списку проєктів, доступних користувачеві.  
* Робота з одним активним проєктом одночасно.

### **2.2 Аутентифікація**

* **Єдиний метод аутентифікації:** через персональний **API Token** GitLab.  
* Механізм автентифікації за логіном/паролем **видалено** для підвищення безпеки та спрощення конфігурації.  
* Надійна перевірка з'єднання, що валідує як URL-адресу, так і API-ключ.

### **2.3 Робота з гілками**

* Отримання та відображення повного списку гілок для обраного проєкту.  
* Можливість обрати **цільову гілку** (напр., master, develop) для аналізу.  
* **Автоматична перевірка статусу змердженості:** асинхронна перевірка кожної гілки відносно обраної цільової гілки з візуальним відображенням результату (✔).  
* Відображення детальної інформації про гілки: назва, дата останнього коміту, статус захисту та ін.

### **2.4 Інтерфейс та взаємодія**

* **Декларативне керування станом кнопок:** кнопки операцій (Видалити...) стають доступними лише тоді, коли відповідна дія є логічно можливою (наприклад, обрано проєкт, є гілки для видалення).  
* **Інтерактивна таблиця:**  
  * Чекбокси для множинного вибору гілок.  
  * Масові операції вибору: "Вибрати все", "Зняти вибір", "Інвертувати вибір".  
* **Динамічна зміна локалі:** миттєве перемикання мови інтерфейсу (українська/англійська) без перезавантаження даних з GitLab.

### **2.5 Операції з гілками**

1. **Видалення обраних гілок:**  
   * Видалення гілок, відмічених користувачем вручну.  
   * Діалог підтвердження перед виконанням операції.  
2. **Видалення змерджених гілок:**  
   * Запит граничної дати через календар.  
   * Видалення гілок, що були змерджені в цільову і є старішими за вказану дату.  
   * Діалог підтвердження зі списком гілок до видалення.  
3. **Видалення незмерджених гілок:**  
   * Видалення старих неактивних гілок, які не були влиті в цільову.  
   * Запит граничної дати.  
   * Діалог підтвердження для запобігання випадковому видаленню важливої роботи.

## **3\. Технічні вимоги**

### **3.1 Архітектура**

Проєкт реалізовано з використанням сучасних архітектурних підходів для JavaFX, що забезпечують чіткий розподіл відповідальності:

* **Архітектурний патерн:** гібридний підхід, що поєднує елементи **MVC та MVVM**.  
  * **View:** Декларативно визначений у файлах .fxml.  
  * **Controller (MainController):** Виступає як посередник, обробляє події UI та делегує логіку сервісам.  
  * **Model:** Представлена декількома класами:  
    * UIStateModel: централізована модель для зберігання **стану UI**. Використовує JavaFX Properties для реактивності.  
    * BranchModel: доменна модель, що описує гілку.  
    * AppConfig: модель для керування конфігурацією.  
* **Сервісний шар:**  
  * GitLabService: інкапсулює всю логіку взаємодії з GitLab API.  
  * LocaleChangeService: керує логікою динамічної зміни локалі.  
* **Асинхронність:**  
  * Усі довготривалі операції (мережеві запити) виконуються у фонових потоках за допомогою ExecutorService.  
  * **Потоки-демони:** ExecutorService налаштований на створення потоків-демонів, що **гарантує коректне завершення роботи додатку** без "зависання".  
  * CompletableFuture використовується для керування послідовністю асинхронних операцій.  
* **Реактивний UI:**  
  * Стан кнопок та інших елементів керується за допомогою **Bindings API**, що забезпечує автоматичне оновлення UI у відповідь на зміну стану моделі.

### **3.2 Збереження налаштувань**

* **Формат:** Файл властивостей (.properties).  
* **Локація:** \~/.config/gitlaberfx/config.properties.  
* **Зміст:** Зберігаються лише базові налаштування: URL GitLab, API-ключ та обрана локаль.

### **3.3 Логування**

* **Фреймворк:** SLF4J \+ Logback.  
* **Конфігурація (logback.xml):** Налаштовано вивід у консоль та у файли з щоденною ротацією.  
* **Рівні логування:** Використовуються для розділення діагностичної інформації та помилок.

### **3.4 GitLab API**

Використовуються наступні ключові ендпоінти:

* GET /api/v4/user: для надійної перевірки з'єднання та валідності токену.  
* GET /api/v4/projects: для отримання списку проєктів.  
* GET /api/v4/projects/:id/repository/branches: для отримання списку гілок.  
* DELETE /api/v4/projects/:id/repository/branches/:branch: для видалення гілки.  
* GET /api/v4/projects/:id/repository/merge\_base: для перевірки статусу змердженості.

## **4\. Нефункціональні вимоги**

### **4.1 Продуктивність**

* UI залишається повністю відгукливим під час виконання всіх фонових операцій.  
* Асинхронне завантаження даних не блокує інтерфейс.  
* Зміна локалі відбувається миттєво, без повторних запитів до мережі.

### **4.2 Надійність**

* **Валідація конфігурації:** програма не виконує мережевих запитів, якщо конфігурація відсутня або некоректна.  
* Користувач отримує зрозумілі повідомлення про помилки замість технічних деталей.  
* Гарантоване завершення роботи додатку без залишкових активних потоків.

### **4.3 Юзабіліті**

* Інтуїтивно зрозумілий інтерфейс.  
* Візуальний зворотний зв'язок (індикатор прогресу, повідомлення в статус-барі) під час тривалих операцій.  
* Інтерактивні підказки (tooltips) для елементів керування.

## **5\. Тестування**

* **Юніт-тести (JUnit 5, Mockito):** Покривають моделі, сервіси та логіку конфігурації.  
* **UI-тести (TestFX):** Можуть бути використані для тестування ключових сценаріїв взаємодії користувача. Розділена архітектура значно спрощує тестування, дозволяючи тестувати логіку MainController ізольовано від UI.