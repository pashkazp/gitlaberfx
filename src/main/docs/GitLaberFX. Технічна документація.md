# GitLaberFX: Технічна документація
## 1. Вступ

  Цей документ надає технічний огляд архітектури та внутрішньої будови додатку GitLaberFX. Він призначений для розробників, які займаються супроводом, модифікацією або подальшим розвитком проєкту. Документація відображає стан проєкту після значного архітектурного рефакторингу, що включає впровадження функціоналу архівації та фільтрації гілок.
## 2. Архітектура додатку

  Проєкт побудований на основі гібридного підходу, що поєднує найкращі практики з патернів **MVC (Model-View-Controller)** та **MVVM (Model-View-ViewModel)**.
### 2.1. Шари архітектури
**Шар Представлення (Presentation Layer):**
   **View:** Декларативно визначений у файлах FXML (main.fxml, delete_confirmation.fxml, filter_panel.fxml). Відповідає за структуру UI.
   **Controller:**
      MainController: Керує головним вікном, оркеструє завантаження даних та операції.
      DeleteConfirmationController: Керує логікою діалогового вікна підтвердження.
      FilterPanelController: Контролер для повторно використовуваного компонента, що інкапсулює логіку фільтрації.
**Шар Моделі (Model Layer):**
   **UIStateModel:** Центральна модель стану UI. Є "єдиним джерелом правди". Ключовою особливістю є ініціалізація ObservableList гілок з **екстрактором (Extractor)**, який відстежує зміни властивостей nameProperty, selectedProperty та mergedIntoTargetProperty, забезпечуючи повну реактивність UI.
   **BranchModel:** Доменна модель, що описує гілку. Містить поле originalName для надійної ідентифікації та конструктор копіювання для ізоляції стану в діалогах.
   **AppConfig:** Модель для керування конфігурацією додатку, включаючи archivePrefix.
**Сервісний Шар (Service Layer):**
   **GitLabService:** Інкапсулює всю логіку взаємодії з GitLab API. Реалізує атомарний метод archiveBranch з механізмом відкату.
   **LocaleChangeService:** Керує логікою динамічної зміни локалі.
### 2.2. Потоки даних та взаємодія
**Фільтрація:** MainController та DeleteConfirmationController передають свої списки гілок у FilterPanelController через метод setTargetList. FilterPanelController маніпулює властивістю selected об'єктів BranchModel напряму, що миттєво відображається в TableView завдяки реактивності.
**Архівація/Видалення:**
   MainController ініціює операцію та відкриває діалог через DialogHelper.
   DeleteConfirmationController повертає OperationConfirmationResult, що містить вибір користувача.
   MainController запускає фонову задачу, яка викликає відповідні методи GitLabService.
   Після завершення, MainController **локально оновлює UIStateModel**:
      Змінює імена архівованих гілок (branch.setName(...)).
      Видаляє видалені гілки (uiStateModel.getCurrentProjectBranches().removeAll(...)).
   Викликає repopulateTargetBranchComboBox() для коректного оновлення випадаючого списку зі збереженням стану.
## 3. Ключові компоненти
### FilterPanelController

  Реалізований як незалежний, повторно використовуваний компонент. Його залежність від даних (списку гілок) впроваджується ззовні, що робить його гнучким та легким для інтеграції.
### GitLabService.archiveBranch

  Ключовий метод, що забезпечує безпеку операції. Його логіка відкату гарантує, що у випадку збою при видаленні старої гілки, система не залишить "осиротілу" архівну копію в репозиторії.
### UIStateModel

  Центр реактивності додатку. Правильно налаштований **екстрактор** є фундаментом, який дозволяє UI автоматично оновлюватися у відповідь на будь-які значущі зміни в моделі даних, включаючи перейменування гілок.
### MainController.executeBranchOperation

  Оркеструє весь складний процес: від отримання вибору користувача до виконання фонової задачі та фінального, чистого оновлення UI без перезавантаження даних.
## 4. Керування асинхронністю
**ExecutorService з потоками-демонами:** Гарантує коректне завершення роботи додатку.
**submitTask():** Централізований метод, що керує прапорцем isBusy у UIStateModel, забезпечуючи блокування/розблокування UI під час виконання фонових операцій.
**CompletableFuture:** Використовується для надійної ініціалізації додатку та послідовного завантаження даних.
## 5. Висновок

  Поточна архітектура gitlaberfx є зрілою, надійною та гнучкою. Вона демонструє ефективне застосування сучасних патернів проєктування для JavaFX, таких як централізована модель стану, реактивні прив'язки та модульні UI-компоненти. Це забезпечує високу супроводжуваність та створює міцну основу для подальшого розвитку функціоналу.