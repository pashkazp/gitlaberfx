# **GitLaberFX: Технічна документація**

## **1\. Вступ**

Цей документ надає технічний огляд архітектури та внутрішньої будови додатку GitLaberFX. Він призначений для розробників, які займаються супроводом, модифікацією або подальшим розвитком проєкту. Документація відображає стан проєкту після значного архітектурного рефакторингу, спрямованого на підвищення надійності, тестованості та супроводжуваності коду.

## **2\. Архітектура додатку**

Проєкт побудований на основі сучасних архітектурних принципів для десктопних додатків JavaFX, використовуючи гібридний підхід, що поєднує найкращі практики з патернів **MVC (Model-View-Controller)** та **MVVM (Model-View-ViewModel)**.

### **2.1. Шари архітектури**

Додаток чітко розділений на три логічні шари:

1. **Шар Представлення (Presentation Layer):**  
   * **View:** Декларативно визначений у файлах FXML. Відповідає виключно за структуру та розміщення елементів UI.  
   * **Controller (MainController):** Виступає як посередник між View та Model. Він ініціалізує компоненти, обробляє події від користувача (кліки, вибір) і делегує всю бізнес-логіку та роботу з даними відповідним сервісам. Він також відповідає за прив'язку стану UI до моделі.  
2. **Шар Моделі (Model Layer):**  
   * **UIStateModel:** Центральний елемент архітектури, що реалізує ідею "єдиного джерела правди" (Single Source of Truth) для стану UI. Він містить усі дані, що відображаються (списки проєктів, гілок), та прапорці стану (наприклад, isBusy). Використання JavaFX Properties робить його реактивним.  
   * **BranchModel, GitLabService.Project:** Доменні моделі, що описують сутності даних. Вони також використовують JavaFX Properties, що дозволяє таблицям та іншим елементам UI автоматично оновлюватися при зміні даних.  
   * **AppConfig:** Модель, що відповідає за завантаження, збереження та валідацію конфігурації додатку.  
3. **Сервісний Шар (Service Layer):**  
   * **GitLabService:** Інкапсулює всю логіку взаємодії з GitLab API. MainController ніколи не робить прямих мережевих запитів, а завжди використовує цей сервіс.  
   * **LocaleChangeService:** Інкапсулює складну логіку динамічної зміни локалі, забезпечуючи плавне перезавантаження UI без втрати даних та повторних мережевих запитів.

### **2.2. Керування станом та потоками даних**

* **Односпрямований потік даних:** Дії користувача в View обробляються в Controller, який викликає методи сервісів. Сервіси повертають дані, які оновлюють UIStateModel. Зміни в UIStateModel автоматично відображаються у View завдяки механізму прив'язок (Bindings).  
* **Реактивність:** Завдяки використанню **FXCollections.observableArrayList з екстрактором (Extractor)** у UIStateModel, Bindings API може реагувати не тільки на додавання/видалення елементів зі списку, але й на зміну властивостей *всередині* кожного елемента (наприклад, branch.mergedIntoTargetProperty()). Це є ключем до коректної роботи декларативного стану кнопок.

## **3\. Ключові компоненти та їхня взаємодія**

### **UIStateModel**

Це центральна модель стану UI. Її головна відповідальність — зберігати актуальні дані, що відображаються в інтерфейсі.

* currentProjectBranches: Список, створений за допомогою FXCollections.observableArrayList(extractor), що дозволяє відстежувати зміни властивостей mergedIntoTarget та selected у кожній BranchModel.  
* isBusy: BooleanProperty, що слугує глобальним прапорцем для всіх фонових операцій. На нього зав'язаний стан активності більшості елементів керування.

### **MainController**

Виконує роль "диригента".

* **initialize()**: Налаштовує прив'язки (Bindings), слухачів подій (Listeners) та ініціалізує початковий стан UI.  
* **setupButtonBindings()**: Найбільш елегантна частина. Декларативно описує умови, за яких кнопки мають бути активними. Ця логіка є самодостатньою і не вимагає ручних викликів setDisable(true/false) з інших частин коду.  
* **handleProjectSelection(), handleTargetBranchSelection()**: Обробники подій, які оновлюють модель стану (UIStateModel) і запускають відповідні фонові задачі.  
* **repopulateFromState()**: Ключовий метод для динамічної зміни локалі. Він дозволяє "наповнити" новий екземпляр контролера вже існуючими даними зі старого, уникаючи повторних запитів до мережі.

### **GitLabService**

Ізолює всю роботу з GitLab API.

* **testConnection()**: Виконує легкий, але надійний запит (/api/v4/user), щоб перевірити одночасно і валідність URL, і коректність API-токену.  
* Усі методи, що виконують запити, захищені перевіркою config.isConfigurationValid(), щоб уникнути помилок при відсутніх налаштуваннях.

### **LocaleChangeService**

Оркеструє процес зміни мови інтерфейсу.

1. Зберігає поточний стан UI (SavedState), включаючи ID та імена обраних пунктів.  
2. Зберігає повну UIStateModel старого контролера.  
3. Перезавантажує FXML-сцену з новою ResourceBundle.  
4. Викликає метод repopulateFromState нового контролера, передаючи йому збережені дані для миттєвого відновлення UI.

## **4\. Керування асинхронністю**

* **ExecutorService та потоки-демони:** Пул потоків створюється за допомогою кастомної ThreadFactory, яка створює потоки з прапорцем setDaemon(true). Це є **гарантованим вирішенням** проблеми "зависання" додатку при виході, оскільки JVM не чекає завершення таких потоків.  
* **submitTask():** Метод-обгортка, який централізує керування фоновими задачами. Він встановлює глобальний прапорець isBusy на початку та знімає його в блоці finally, гарантуючи, що UI завжди повернеться в активний стан, навіть у разі помилки в задачі.  
* **CompletableFuture:** Використовується для оркестрації послідовності асинхронних дій, наприклад, при старті програми (startInitialLoad), де потрібно спочатку завантажити проєкти, а вже потім встановити початкове значення "не обрано".

## **5\. Процес запуску та відновлення стану**

1. **GitlaberApp.start():**  
   * Ініціалізує конфігурацію та локаль.  
   * Створює екземпляр MainController.  
   * Викликає controller.startInitialLoad(), який повертає CompletableFuture.  
   * Додає до CompletableFuture дію thenRunAsync(controller::selectInitialProject), яка виконається **після** завершення завантаження проєктів, коректно встановлюючи початковий стан ComboBox.  
2. **LocaleChangeService.changeLocale():**  
   * Зберігає стан старого контролера.  
   * Створює новий екземпляр MainController.  
   * Викликає newController.repopulateFromState(), передаючи дані зі старого контролера. Цей метод програмно відновлює стан UI без виклику мережевих запитів та без активації зайвих слухачів подій.

Ця архітектура забезпечує надійність, гнучкість та чудовий досвід користувача, мінімізуючи мережеві запити та забезпечуючи миттєву реакцію інтерфейсу.