# GitLaberFX: Технічна документація

## 1. Вступ

Цей документ надає технічний огляд архітектури та внутрішньої будови додатку GitLaberFX. Він призначений для розробників, які займаються супроводом, модифікацією або подальшим розвитком проєкту. Документація відображає стан проєкту після значного архітектурного рефакторингу, що включає впровадження функціоналу архівації та фільтрації гілок.

## 2. Архітектура додатку

Проєкт побудований на основі гібридного підходу, що поєднує найкращі практики з патернів **MVC (Model-View-Controller)** та **MVVM (Model-View-ViewModel)**.

### 2.1. Шари архітектури

#### 2.1.1. Шар Представлення (Presentation Layer)

- **View:** 
  - Декларативно визначений у файлах FXML (main.fxml, delete_confirmation.fxml, filter_panel.fxml, date-selector.fxml)
  - Відповідає за структуру UI

- **Controller:**
  - **MainController:** Керує головним вікном, оркеструє завантаження даних та операції
  - **DeleteConfirmationController:** Керує логікою діалогового вікна підтвердження
  - **FilterPanelController:** Контролер для повторно використовуваного компонента, що інкапсулює логіку фільтрації
  - **DateFilterPanelController:** Керує фільтрацією гілок за датою останнього коміту
  - **DateSelectorController:** Забезпечує вибір діапазону дат для фільтрації

#### 2.1.2. Шар Моделі (Model Layer)

- **UIStateModel:** 
  - Центральна модель стану UI
  - Є "єдиним джерелом правди"
  - Ключовою особливістю є ініціалізація ObservableList гілок з **екстрактором (Extractor)**, який відстежує зміни властивостей nameProperty, selectedProperty та mergedIntoTargetProperty, забезпечуючи повну реактивність UI

- **BranchModel:** 
  - Доменна модель, що описує гілку
  - Містить поле originalName для надійної ідентифікації
  - Має конструктор копіювання для ізоляції стану в діалогах

- **AppConfig:** 
  - Модель для керування конфігурацією додатку, включаючи archivePrefix

#### 2.1.3. Сервісний Шар (Service Layer)

- **GitLabService:** 
  - Інкапсулює всю логіку взаємодії з GitLab API
  - Реалізує атомарний метод archiveBranch з механізмом відкату

- **LocaleChangeService:** 
  - Керує логікою динамічної зміни локалі

### 2.2. Потоки даних та взаємодія

#### 2.2.1. Фільтрація

- MainController та DeleteConfirmationController передають свої списки гілок у FilterPanelController через метод setTargetList
- FilterPanelController маніпулює властивістю selected об'єктів BranchModel напряму, що миттєво відображається в TableView завдяки реактивності

#### 2.2.2. Архівація/Видалення

1. MainController ініціює операцію та відкриває діалог через DialogHelper
2. DeleteConfirmationController повертає OperationConfirmationResult, що містить вибір користувача
3. MainController запускає фонову задачу, яка викликає відповідні методи GitLabService
4. Після завершення, MainController **локально оновлює UIStateModel**:
   - Змінює імена архівованих гілок (branch.setName(...))
   - Видаляє видалені гілки (uiStateModel.getCurrentProjectBranches().removeAll(...))
5. Викликає repopulateTargetBranchComboBox() для коректного оновлення випадаючого списку зі збереженням стану

## 3. Ключові компоненти

### 3.1. FilterPanelController

Реалізований як незалежний, повторно використовуваний компонент. Його залежність від даних (списку гілок) впроваджується ззовні, що робить його гнучким та легким для інтеграції.

### 3.2. DateFilterPanelController

Компонент для фільтрації гілок за датою останнього коміту. Дозволяє користувачу вибирати діапазон дат (до та/або після) та включати або виключати гілки, що відповідають цим критеріям.

### 3.3. DateSelectorController

Реалізує діалогове вікно для вибору діапазону дат. Використовує патерн Builder для гнучкого створення та налаштування. Забезпечує валідацію введених дат та повертає результат через спеціальний клас DateSelectorResult.

### 3.4. GitLabService.archiveBranch

Ключовий метод, що забезпечує безпеку операції. Його логіка відкату гарантує, що у випадку збою при видаленні старої гілки, система не залишить "осиротілу" архівну копію в репозиторії.

### 3.5. GitLabService.deleteBranch

Метод для видалення гілок з покращеною обробкою помилок. Забезпечує детальне логування та чітку ідентифікацію причин збоїв, що спрощує діагностику проблем.

### 3.6. UIStateModel

Центр реактивності додатку. Правильно налаштований **екстрактор** є фундаментом, який дозволяє UI автоматично оновлюватися у відповідь на будь-які значущі зміни в моделі даних, включаючи перейменування гілок.

### 3.7. MainController.executeBranchOperation

Оркеструє весь складний процес: від отримання вибору користувача до виконання фонової задачі та фінального, чистого оновлення UI без перезавантаження даних.

## 4. Керування асинхронністю

- **ExecutorService з потоками-демонами:** 
  - Гарантує коректне завершення роботи додатку

- **submitTask():** 
  - Централізований метод, що керує прапорцем isBusy у UIStateModel
  - Забезпечує блокування/розблокування UI під час виконання фонових операцій

- **CompletableFuture:** 
  - Використовується для надійної ініціалізації додатку та послідовного завантаження даних

## 5. Висновок

Поточна архітектура gitlaberfx є зрілою, надійною та гнучкою. Вона демонструє ефективне застосування сучасних патернів проєктування для JavaFX, таких як централізована модель стану, реактивні прив'язки та модульні UI-компоненти. Це забезпечує високу супроводжуваність та створює міцну основу для подальшого розвитку функціоналу.
